# Get upstream changes for a fork {#upstream-changes}

This workflow is relevant if you have done [fork and clone](#fork-and-clone) and now you need to pull subsequent changes from the source repo into your copy.
We are talking about both your fork (your remote copy of the repo, on GitHub) and your local copy.

## Prep work

Vocabulary: `OWNER/REPO` refers to what we call the **source** repo, owned by `OWNER`, who is not you.
`YOU/REPO` refers to your fork, i.e. your remote copy of the source repo, on GitHub.
This is a good time to get the main page of your fork `YOU/REPO` open in a web browser.

Locally, get into your local copy of the repo.
For many readers, this means launching it as an RStudio Project.
You may also want to open a terminal (Appendix \@ref(shell)) within RStudio for some Git work via *Tools > Terminal > New Terminal*.

Make sure you are on the default branch, e.g. `main`, and that your "working tree is clean".
`git status` should show something like:

``` bash
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```

BTW I recommend that you [never make your own commits to the default branch of a fork](#dont-touch-main) or to any branch that you don't effectively (co-)own.
This creates a divergence between that branch's history in the source repo and in your repo, which creates pain for you.
However, if you have already done so, we are going to address your sorry situation below.

## List your remotes

Let's inspect [the current remotes](#git-remotes) for your local repo.

### Command line Git

In the shell (Appendix \@ref(shell)):

``` bash
git remote -v
```

Some of you will see output along these lines:

``` bash
origin  https://github.com/YOU/REPO.git (fetch)
origin  https://github.com/YOU/REPO.git (push)
```

There is only one remote, named `origin`, corresponding to your fork on GitHub, which you then cloned locally.
This figure depicts this scenario:

```{r fork-no-upstream-sad, echo = FALSE, out.width = "60%", fig.cap = "Fork where `upstream` is not configured."}
knitr::include_graphics("img/fork-no-upstream-sad.jpeg")
```

This is sad, because there is no direct connection between your local copy of the repo and the source repo `OWNER/REPO`.
Elsewhere in this site we describe [common remote setups](#common-remote-setups) and this one is called "Fork (salvageable)", indicating it's a fork that's not fully configured.
usethis calls this configuration `"fork_upstream_is_not_origin_parent"`.

A more functional remote setup looks like this:

``` bash
origin    https://github.com/YOU/REPO.git (fetch)
origin    https://github.com/YOU/REPO.git (push)
upstream  https://github.com/OWNER/REPO.git (fetch)
upstream  https://github.com/OWNER/REPO.git (push)
```

Notice the second remote, named `upstream`, corresponding to the source repo on GitHub.
This figure depicts this scenario, i.e. the one we want to achieve:

```{r fork-triangle-happy, echo = FALSE, out.width = "60%", fig.cap = "Fork where `upstream` is configured."}
knitr::include_graphics("img/fork-them.jpeg")
```

Elsewhere in the book we describe [common remote setups](#common-remote-setups) and this is the setup we like to see for a fork.

Sidebar: If you used `usethis::create_from_github("OWNER/REPO", fork = TRUE)` for your original "fork and clone", the `upstream` will already be set up.
In that case, you can skip ahead.

But sometimes you have done "fork and clone" another way and you haven't configured the source repo as the `upstream` remote.
This often becomes an issue when you're taking an interest in someone else's work for the second time and you want to make another pull request.
Or maybe you just want your copy to reflect their recent work.
In any case, this setup can be done upon first need.

### usethis

usethis will display your remotes via `git_remotes()`.
In R, you'll see something like this:

```{r eval = FALSE}
git_remotes()
#> $origin
#> [1] "https://github.com/YOU/REPO.git"
#> 
#> $upstream
#> [1] "https://github.com/OWNER/repo.git"
```

## View the upstream tracking branch

It is also helpful to be intentional about the upstream tracking branch of your local `main` branch.
Despite the name, it is not necessarily `upstream/main` (although that is what I recommend).
That will be the case if you used `usethis::create_from_github("OWNER/REPO", fork = TRUE)` to fork-and-clone.

Other fork-and-clone workflows do not configure the `upstream` remote, which implies that it would be impossible for local `main` to be tracking `upstream/main`.
In this case, local `main` is presumably tracking `origin/main`.

You can see upstream tracking information for your branches with `git branch -vv`.
If you have an `origin` remote, but no `upstream`, you'll see something like this:

``` bash
~/some/repo/ % git branch -vv                                                      
* main 2739987 [origin/main] Some commit message
```

In the preferred setup, with an `upstream` remote, ideally we see something like this:

``` bash
~/some/repo/ % git branch -vv                   
* main 2739987 [upstream/main] Some commit message
```

## Verify your `upstream` remote

Let's inspect [the current remotes](#git-remotes) for your local repo AGAIN. In the shell:

``` bash
git remote -v
```

Now everyone should see something like

``` bash
origin    https://github.com/YOU/REPO.git (fetch)
origin    https://github.com/YOU/REPO.git (push)
upstream  https://github.com/OWNER/REPO.git (fetch)
upstream  https://github.com/OWNER/REPO.git (push)
```

Notice the second remote, named `upstream`, corresponding to the original repo on GitHub. We have gotten to this:

```{r fork-triangle-happy-2, echo = FALSE, out.width = "60%", fig.cap = "Fork where `upstream` is configured."}
knitr::include_graphics("img/fork-them.jpeg")
```

## Option 1: Pull changes from `upstream`, then push to `origin`

Now we are ready to pull the changes that we don't have from the source repo `OWNER/REPO` into our local copy.

``` bash
git pull upstream main --ff-only
```

This says: "pull the changes from the remote known as `upstream` into the `main` branch of my local repo".
I am being explicit about the remote and the branch in this case, both to make it more clear and to make this command robust to repo- and user-level Git configurations.

I **highly recommend** using the `--ff-only` flag in this case, so that you also say "if I have made my own commits to `main`, please force me to confront this problem NOW".
Here's what it looks like if a fast-forward merge isn't possible:

``` bash
$ git pull upstream main --ff-only
From github.com:OWNER/REPO
 * branch              main     -> FETCH_HEAD
fatal: Not possible to fast-forward, aborting.
```

See [Um, what if I did touch `main`?](#touched-main) to get yourself back on the happy path.

This next step is optional and many people who are facile with Git do not bother.

If you take my advice to [never work in `main` of a fork](#dont-touch-main), then the state of the `main` branch in your fork `YOU/REPO` does not technically matter.
You will never make a pull request from `main` and there are ways to set the correct base for the branches and pull requests that you do create.

If, however, your grasp of all these Git concepts is tenuous at best, it can be helpful to try to keep things simple and orderly and synced up.

Feel free to push the newly updated state of local `main` to your fork `YOU/REPO` and enjoy the satisfaction of being "caught up" with `OWNER/REPO`, in both your remote fork and in your local repo.

In the shell:

``` bash
git push origin main
```

## Option 2: Sync your fork on GitHub, pull changes from `origin` to local repo

For many years, this was not possible, though many GitHub users wished for this feature.
Happily it is now possible to sync a fork with its source repo in the browser, i.e. to do the sync between the 2 GitHub repos.
The official GitHub documentation for this is [Syncing a fork from the web UI](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/syncing-a-fork#syncing-a-fork-from-the-web-ui).

Navigate to the main page of your fork `YOU/REPO`.

Towards the upper right corner, you will see "Fetch upstream".
Click this and then click "Fetch and merge".
Upon success, the main page of `YOU/REPO` shows something like

> This branch is up to date with `OWNER/REPO:main`.

If this does not "just work", it probably means you have made commits on the default branch of your fork, which we [strongly advise against](#dont-touch-main).
I believe GitHub then gives you the option of bringing the `upstream` changes into your fork as a pull request.
Alternatively, you could back out and straighten out the history of the default branch, using the instructions below.
Then you could do a force push to `origin` and try the sync again.

Once you have successfully synced the default branch of `YOU/REPO` with the default branch of `OWNER/REPO`, you probably want to do the same for your local repo.
Since they are synced, you can pull from either `upstream` or `origin`.

In the shell, with the default branch check out, execute one of these:

``` bash
git pull origin
git pull upstream
```

## Um, what if I did touch `main`? {#touched-main}

I told you not to!

But OK here we are.

Let's imagine this is the state of the source repo `OWNER/REPO`:

``` bash
... -- A -- B -- C -- D -- E -- F
```

and and this is the state of the `main` branch in your local copy:

``` bash
... -- A -- B -- C -- X -- Y -- Z
```

The two histories agree, up to commit or state `C`, then they diverge.

If you want to preserve the work in commits `X`, `Y`, and `Z`, create a new branch right now, with tip at `Z`, via `git checkout -b my-great-innovations` (pick your own branch name!).
Then checkout `main` via `git checkout main`.

I now assume you have either preserved the work in `X`, `Y`, and `Z` (with a branch) or have decided to let it go.

Do a hard reset of the `main` branch to `C`.

``` bash
git reset --hard C
```

You will have to figure out how to convey `C` in Git-speak. Specify it relative to `HEAD` or provide the SHA. See *future link about resets* for more support.

The instructions above for pulling changes from `upstream` should now work.
Your `main` branch should reflect the history of `OWNER/REPO`:

``` bash
... -- A -- B -- C -- D -- E -- F
```

If you chose to create a branch with your work, you will also have that locally:


``` bash
... -- A -- B -- C -- D -- E -- F (main)
                   \
                    -- X -- Y -- Z (my-great-innovations)
```

If you pushed your alternative history (with commits `X`, `Y`, and `Z`) to your fork `YOU/REPO` and you like keeping everything synced up, you will also need to force push `main` via `git push --force`, but we really really don't like discussing force pushes in Happy Git.
We only do so here, because we are talking about a fork, which is fairly easy to replace if things go sideways.
